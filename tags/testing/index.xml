<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Testing on Jens Rantil</title><link>https://jensrantil.github.io/tags/testing/</link><description>Recent content in Testing on Jens Rantil</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 19 Sep 2025 22:22:03 +0200</lastBuildDate><atom:link href="https://jensrantil.github.io/tags/testing/index.xml" rel="self" type="application/rss+xml"/><item><title>Business contracts are transport agnostic</title><link>https://jensrantil.github.io/posts/simple-contract-testing/</link><pubDate>Sun, 27 Apr 2025 13:40:35 +0200</pubDate><guid>https://jensrantil.github.io/posts/simple-contract-testing/</guid><description>&lt;p>I have never been a big fan of how some people equate &amp;ldquo;contract testing&amp;rdquo; with using something like &lt;a href="https://docs.pact.io" class="external-link" target="_blank" rel="noopener">PACT&lt;/a>. There are other ways of doing contract testing, but a lot of engineers don&amp;rsquo;t seem to know this. Today, I thought I would write something about this.&lt;/p>
&lt;h2 id="contract-testing">
 Contract testing?
 &lt;a class="heading-link" href="#contract-testing">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>&lt;em>Contract testing&lt;/em> is about making sure that two pieces of software (usually two services) can communicate correctly with each other, and that they agree on how they should talk.&lt;/p></description></item><item><title>The Dangers of an IDE</title><link>https://jensrantil.github.io/posts/integrated-development-environments-harmful/</link><pubDate>Tue, 11 Mar 2025 10:38:35 +0200</pubDate><guid>https://jensrantil.github.io/posts/integrated-development-environments-harmful/</guid><description>&lt;p>&lt;em>I recently stumbled across the post &lt;a href="https://charlespetzold.com/etc/DoesVisualStudioRotTheMind.html" class="external-link" target="_blank" rel="noopener">&amp;ldquo;Does Visual Studio Rot The Mind?&amp;rdquo;&lt;/a> and I was reminded of a blog post that I read a very long time ago and could not find on the Internet. I thought I would write down the gist of that article here such that I can share links to it later.&lt;/em>&lt;/p>
&lt;p>There is this theory that the best and most beautiful code was written before the nineties, before the introduction of modern &lt;emph title="Integrated Development Environments">IDEs&lt;/emph> such as VSCode, Eclipse, IntelliJ, Visual Studio, et al. Why? It forced programmers to keep their code in their heads.&lt;/p></description></item><item><title>Reliability vs. Resilience</title><link>https://jensrantil.github.io/posts/safety-type-1-and-2/</link><pubDate>Tue, 05 Nov 2024 16:19:35 +0200</pubDate><guid>https://jensrantil.github.io/posts/safety-type-1-and-2/</guid><description>&lt;p>In safety systems engineering (SSE) people talk about &amp;ldquo;safety type 1&amp;rdquo; and &amp;ldquo;safety type 2&amp;rdquo;. The first one is about prevention &amp;amp; &lt;strong>reliability&lt;/strong>, the second is about &lt;strong>resilience&lt;/strong>. Type 1 has been around for a long time, and type 2 is &lt;a href="https://www.england.nhs.uk/signuptosafety/wp-content/uploads/sites/16/2015/10/safety-1-safety-2-whte-papr.pdf" class="external-link" target="_blank" rel="noopener">fairly new&lt;/a>.&lt;/p>
&lt;h2 id="prevention-will-not-save-us">
 Prevention will not save us
 &lt;a class="heading-link" href="#prevention-will-not-save-us">
 &lt;i class="fa-solid fa-link" aria-hidden="true" title="Link to heading">&lt;/i>
 &lt;span class="sr-only">Link to heading&lt;/span>
 &lt;/a>
&lt;/h2>
&lt;p>Software systems (and software companies) are complex. And for complex systems, type 1 safety (prevention) will not save us. Three key reasons:&lt;/p></description></item><item><title>On staging environments</title><link>https://jensrantil.github.io/posts/on-staging-environments/</link><pubDate>Sun, 12 May 2024 15:44:35 +0200</pubDate><guid>https://jensrantil.github.io/posts/on-staging-environments/</guid><description>&lt;blockquote>
&lt;p>The ultimate quality assurance is when customers get their hands on your
software and actually try it. &lt;em>That&amp;rsquo;s&lt;/em> when you know if your software does what
it&amp;rsquo;s supposed to do or not. This happens in production.&lt;/p>
&lt;/blockquote>
&lt;p>Every technical decision has a tradeoff, but certain things are
rarely challenged in our industry. Having a staging environment&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>, and having
every change go through that staging environment, are two of those things.&lt;/p>
&lt;p>So, what is a staging environment? It is a full replica of a production
environment. Do you have a backend service running in production? Then you also
need that service in staging. Do you have a database in production? Then you
need a database in your staging environment. Etcetera. Most companies having a
staging environment require every change to first go through staging to verify
that the change works before hitting production.&lt;/p></description></item><item><title>My simplicity toolkit: Testing</title><link>https://jensrantil.github.io/posts/software-testing-simplicity/</link><pubDate>Sun, 18 Feb 2024 09:45:35 +0200</pubDate><guid>https://jensrantil.github.io/posts/software-testing-simplicity/</guid><description>&lt;div class="notice info">
 &lt;div class="notice-title">
 &lt;i class="fa-solid fa-exclamation-circle" aria-hidden="true">&lt;/i>Info
 &lt;/div>
 &lt;div class="notice-content">This post is part of my blog series about &lt;a href="https://jensrantil.github.io/categories/my-simplicity-toolkit/" >&lt;em>My Simplicity
Toolkit&lt;/em>&lt;/a>. I highly suggest you read &lt;a href="https://jensrantil.github.io/posts/my-simplicity-toolkit/" >the introductory post&lt;/a> before reading this one.&lt;/div>
&lt;/div>

&lt;p>In &lt;a href="https://jensrantil.github.io/posts/my-simplicity-toolkit/" >my initial post&lt;/a> on this blog post series I wrote about
the verb &lt;a href="https://www.youtube.com/watch?si=AYiDh-n_KMwCLwl4&amp;amp;t=1895&amp;amp;v=SxdOUGdseq4&amp;amp;feature=youtu.be" class="external-link" target="_blank" rel="noopener">&amp;ldquo;to complect&amp;rdquo;&lt;/a>. It means to braid something together. In
this article, I am giving examples of things related to testing that tend to be
unnecessarily complected together.&lt;/p>
&lt;p>Building up a suite of maintainable tests is all about trying to avoid
complecting things unless truly necessary. Notice that complecting things
&lt;em>is&lt;/em> necessary at times, just not always.&lt;/p></description></item><item><title>On narrow integration tests</title><link>https://jensrantil.github.io/posts/narrow-integration-tests/</link><pubDate>Mon, 13 Jan 2020 00:00:00 +0000</pubDate><guid>https://jensrantil.github.io/posts/narrow-integration-tests/</guid><description>&lt;p>&lt;em>Narrow integration tests&lt;/em> are tests that only involve very few components,
mostly relying on &lt;a href="https://martinfowler.com/articles/mocksArentStubs.html" class="external-link" target="_blank" rel="noopener">test
doubles&lt;/a> to simulate
external dependencies. As always, we have Martin Fowler to thank for yet
another excellent
&lt;a href="https://martinfowler.com/bliki/IntegrationTest.html" class="external-link" target="_blank" rel="noopener">article&lt;/a> on integration
tests so I&amp;rsquo;ll simply refer to that for the details of what a narrow integration
test is.&lt;/p>
&lt;p>That said, during 2019 I have grown increasingly convinced that the distinction
between a narrow and wide integration (also know as &lt;em>system tests&lt;/em> or &lt;em>end-to-end tests&lt;/em>) is an important one, for two reasons:&lt;/p></description></item><item><title>Testing strategy over time</title><link>https://jensrantil.github.io/posts/testing-strategy-over-time/</link><pubDate>Sun, 12 Jan 2020 00:00:00 +0000</pubDate><guid>https://jensrantil.github.io/posts/testing-strategy-over-time/</guid><description>&lt;p>Last year (2019) I spent a fair amount of time thinking about how to grow
&lt;a href="https://www.tinkapp.com" class="external-link" target="_blank" rel="noopener">Tink&amp;rsquo;s&lt;/a> technical platform; how to organise ourselves
&amp;ndash; alignment vs. autonomy. What processes, tooling, and policies were needed
for our teams to build amazing, stable, performant things at a fast pace? Tink
had essentially doubled in size yearly for four years and the growth had really
pushed our engineering organization to the limits. We are now around 150
engineers. We were less than 10 engineers when I started in early 2014.&lt;/p></description></item></channel></rss>