<!doctype html><html lang=en><head><title>Refreshable AngularJS service · Jens Rantil
</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=color-scheme content="light dark"><meta name=author content="Jens Rantil"><meta name=description content="Lately I&rsquo;ve been working a lot in AngularJS.
This is my second project with the framework, and the more time I spend
in it, the more I like it.
But as with most things, AngularJS has some rough corners. Its
documentation still has a long way to go,
although it has improved since last time I used it over a year ago.
Common use cases and &ldquo;Angular-y&rdquo; was of doing things is another thing
that I also feel is lacking out there. I guess it could be considered
documentation depending on how you look at it."><meta name=keywords content="blog,developer,staff engineering,personal"><meta name=twitter:card content="summary"><meta name=twitter:title content="Refreshable AngularJS service"><meta name=twitter:description content="Lately I’ve been working a lot in AngularJS. This is my second project with the framework, and the more time I spend in it, the more I like it.
But as with most things, AngularJS has some rough corners. Its documentation still has a long way to go, although it has improved since last time I used it over a year ago. Common use cases and “Angular-y” was of doing things is another thing that I also feel is lacking out there. I guess it could be considered documentation depending on how you look at it."><meta property="og:url" content="https://jensrantil.github.io/posts/refreshable-angularjs-service/"><meta property="og:site_name" content="Jens Rantil"><meta property="og:title" content="Refreshable AngularJS service"><meta property="og:description" content="Lately I’ve been working a lot in AngularJS. This is my second project with the framework, and the more time I spend in it, the more I like it.
But as with most things, AngularJS has some rough corners. Its documentation still has a long way to go, although it has improved since last time I used it over a year ago. Common use cases and “Angular-y” was of doing things is another thing that I also feel is lacking out there. I guess it could be considered documentation depending on how you look at it."><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-05-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-22T00:13:45+02:00"><meta property="article:tag" content="AngularJS"><meta property="article:tag" content="JavaScript"><link rel=canonical href=https://jensrantil.github.io/posts/refreshable-angularjs-service/><link rel=preload href=/fonts/fa-brands-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-regular-400.woff2 as=font type=font/woff2 crossorigin><link rel=preload href=/fonts/fa-solid-900.woff2 as=font type=font/woff2 crossorigin><link rel=stylesheet href=/css/coder.min.7763f8bc6341ecf82378e867c285e1549abb063a899be313ccd25dbfcd24fa7d.css integrity="sha256-d2P4vGNB7PgjeOhnwoXhVJq7BjqJm+MTzNJdv80k+n0=" crossorigin=anonymous media=screen><link rel=stylesheet href=/css/coder-dark.min.a00e6364bacbc8266ad1cc81230774a1397198f8cfb7bcba29b7d6fcb54ce57f.css integrity="sha256-oA5jZLrLyCZq0cyBIwd0oTlxmPjPt7y6KbfW/LVM5X8=" crossorigin=anonymous media=screen><link rel=stylesheet href=/custom.min.2e198fefc57dcc517a51f5b2040b841f014759bd551d4dd18df6dd0c1b954a62.css integrity="sha256-LhmP78V9zFF6UfWyBAuEHwFHWb1VHU3RjfbdDBuVSmI=" crossorigin=anonymous media=screen><link rel=icon type=image/svg+xml href=/images/favicon.svg sizes=any><link rel=icon type=image/png href=/images/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/images/favicon-16x16.png sizes=16x16><link rel=apple-touch-icon href=/images/apple-touch-icon.png><link rel=apple-touch-icon sizes=180x180 href=/images/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=mask-icon href=/images/safari-pinned-tab.svg color=#5bbad5></head><body class="preload-transitions colorscheme-auto"><div class=float-container><a id=dark-mode-toggle class=colorscheme-toggle><i class="fa-solid fa-adjust fa-fw" aria-hidden=true></i></a></div><main class=wrapper><nav class=navigation><section class=container><a class=navigation-title href=https://jensrantil.github.io/>Jens Rantil
</a><input type=checkbox id=menu-toggle>
<label class="menu-button float-right" for=menu-toggle><i class="fa-solid fa-bars fa-fw" aria-hidden=true></i></label><ul class=navigation-list><li class=navigation-item><a class=navigation-link href=/posts/>Blog</a></li><li class=navigation-item><a class=navigation-link href=/pages/services/>Services</a></li><li class=navigation-item><a class=navigation-link href=/pages/about-me/>About</a></li></ul></section></nav><div class=content><section class="container post"><article><header><div class=post-title><h1 class=title><a class=title-link href=https://jensrantil.github.io/posts/refreshable-angularjs-service/>Refreshable AngularJS service</a></h1></div><div class=post-meta><div class=date><span class=posted-on><i class="fa-solid fa-calendar" aria-hidden=true></i>
<time datetime=2013-05-23T00:00:00Z>May 23, 2013
</time></span><span class=reading-time><i class="fa-solid fa-clock" aria-hidden=true></i>
6-minute read</span></div><div class=tags><i class="fa-solid fa-tag" aria-hidden=true></i>
<span class=tag><a href=/tags/angularjs/>AngularJS</a>
</span><span class=separator>•</span>
<span class=tag><a href=/tags/javascript/>JavaScript</a></span></div></div></header><div class=post-content><p>Lately I&rsquo;ve been working a lot in <a href=http://angularjs.org class=external-link target=_blank rel=noopener>AngularJS</a>.
This is my second project with the framework, and the more time I spend
in it, the more I like it.</p><p>But as with most things, AngularJS has some rough corners. Its
<a href=http://docs.angularjs.org/ class=external-link target=_blank rel=noopener>documentation</a> still has a long way to go,
although it has improved since last time I used it over a year ago.
Common use cases and &ldquo;Angular-y&rdquo; was of doing things is another thing
that I also feel is lacking out there. I guess it could be considered
documentation depending on how you look at it.</p><p>My intention with this blog post is to go through one such use case,
namely dealing with complex dependencies. The clientside application
that I&rsquo;ve been working with lately has a bunch of quite complicated
dependencies and these JSFiddles turned out to be the perfect way for me
to flesh out how to deal with the dependencies in an structured fashion.
Specifically, this post will talk about:</p><ul><li>How to share state between controllers.</li><li>How update/refresh state between controllers.</li></ul><p>The level of this tutorial is <em>intermediate</em>. I expect you to know basic
AngularJS; state injection, controllers, about <code>$timeout</code> and services.</p><h2 id=a-slow-service>A slow service
<a class=heading-link href=#a-slow-service><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s say you have some data you would like to present to your user and
you prepare some data in your controller. In our case, a list:</p><iframe width=100% height=150 src=http://jsfiddle.net/Ztyx/U9A32/1/embedded/ allowfullscreen frameborder=0></iframe>
This is very basic AngularJS and I expect you to have no problems
understanding the mapping done here.<p>But in the real world, we rarely hardcode things. We are usually
interested in dynamic data. There are two (major) alternatives to get
dynamic data into an AngularJS browser application - either generating
the data into your JS code, or you make an API call to your backend
after your AngularJS application has loaded. The latter is better if
your data takes some time to generate. If you have multiple
dependencies, fetching them asynchronously using multiple HTTP calls
usually also tend to decrease page loading times.</p><p>Now, let&rsquo;s create a
<a href=http://docs.angularjs.org/guide/dev_guide.services class=external-link target=_blank rel=noopener>service</a> that
simulates a slower API call. It uses a
<a href=http://docs.angularjs.org/api/ng.$q class=external-link target=_blank rel=noopener>promise</a> to return an handler that
deals with handling asynchronous result. Here&rsquo;s the code:</p><iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/2/embedded/ allowfullscreen frameborder=0></iframe>
Notice that it takes a couple of seconds before the result is presented
on the screen when you click "Result".<p>Also, it&rsquo;s worth making a mental note that we are storing <em>a promise</em> to
the scope. This is not the same as the actual list. AngularJS
automatically resolves this as the actual returned list and presents it
in the generated HTML. One issue with saving a promises directly to the
scope is that you don&rsquo;t handle how to deal with errors if the promise
could not be resolved. Errors <em>do</em> happen, and in most cases you are
better off explicitly dealing with then. Maybe you can simply ignore it?
Present an error message? Revert to the previous message? This why I
nowadays usually resolve all my promises like this:</p><iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/3/embedded/ allowfullscreen frameborder=0></iframe>
Obviously, we are not generating any errors here, but you never know! ;)<h2 id=refreshable-data-between-controllers>Refreshable data between controllers
<a class=heading-link href=#refreshable-data-between-controllers><i class="fa-solid fa-link" aria-hidden=true title="Link to heading"></i>
<span class=sr-only>Link to heading</span></a></h2><p>Let&rsquo;s say we would like share state between controllers. This can be
done by nesting controllers. Here&rsquo;s a basic example:</p><iframe width=100% height=200 src=http://jsfiddle.net/Ztyx/U9A32/4/embedded/ allowfullscreen frameborder=0></iframe>
Now, let's say that we would like this state to to refresh ones in a
while. Let's simulate an element added:
<iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/5/embedded/ allowfullscreen frameborder=0></iframe>
If you click "Result", you'll notice that the two child controllers are
not being updated after 3 seconds. That's because their `$scope` members
only are set when the child controllers are being created. What we want
is to [watch](http://docs.angularjs.org/api/ng.$rootScope.Scope#$watch)
changes made to the list:
<iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/6/embedded/ allowfullscreen frameborder=0></iframe>
If you try the code above, you'll notice that it still doesn't work. The
reason is subtle; `$scope.$watch` compares object by reference by
default. This means that it will check to see if `$scope.mylist` is a
*different* array than previously. It is not -- it's simply a modified
version of that same array. What we want is to compare for *object
equality*. We do that by setting the third parameter to `true` when
calling `$scope.$watch`:
<iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/8/embedded/ allowfullscreen frameborder=0></iframe>
Finally, it works! But, as in the previous example, we want to avoid
sharing data between controllers through a parent controller. Instead,
we want to use a service:
<iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/10/embedded/ allowfullscreen frameborder=0></iframe>
All good in the hood so far. Now, let's say we would like to support
refreshing data from our slow API endpoint. Maybe the user has a little
refresh button, or you'd like the controller to issue a refresh. This is
where things get a little messy.<p>My first take on this:</p><iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/11/embedded/ allowfullscreen frameborder=0></iframe>
For simplicity, I've only included a single controller.<p>Notice that my service now returns an object with the function refresh()
bound to it. The refresh() member function returns a new promise every
time it&rsquo;s called.</p><p>Looking at the result we notice that the result is presented correctly.
However, what&rsquo;s interesting is that <code>$scope.watchCallbackCalls</code>
eventually gets the value <code>4</code>. This is because our promise returned from
<code>refresh()</code> actually is modified twice; first when it&rsquo;s returned by
<code>refresh()</code> and secondly when the promise is resolved. Since we call
<code>refresh()</code> twice, our watcher gets called four times. The expected
number of watch callback calls are obviously 2 calls.</p><p>How do we overcome this? Instead of using watchers on promises, we
<a href=http://docs.angularjs.org/api/ng.$rootScope.Scope#$on class=external-link target=_blank rel=noopener>can</a>
<a href=http://docs.angularjs.org/api/ng.$rootScope.Scope#$emit class=external-link target=_blank rel=noopener>use</a>
<a href=http://docs.angularjs.org/api/ng.$rootScope.Scope#$broadcast class=external-link target=_blank rel=noopener>events</a>
when our promises are resolved:</p><iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/12/embedded/ allowfullscreen frameborder=0></iframe>
Each event is triggered with newly fetched list as event argument.<p>Since the service can&rsquo;t access the controller that uses it, we trigger
events from <code>$rootScope</code>. For bigger applications you might want to use
the calling controller as a parameter to <code>refresh()</code> to avoid bloating
the <code>$rootScope</code> with too many events (and possibly get conflicting
event names).</p><p>Another nice property of using events is that also other services could
have <code>MySimulatedSlowHTTPService</code> as a dependency and automatically get
triggered when a new result would have been fetched. Making multiple
HTTP API calls to fetch the same resource would be both a waste of time
and bandwidth.</p><p>You can also choose <em>not</em> to refresh certain controller scopes on
refresh. See <code>MyListLengthController</code> here:</p><iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/30/embedded/ allowfullscreen frameborder=0></iframe>
A reason why you would want to do this would be if DOM generation is
slow and the resource being updated is a large one.<p>One issue with the above solution is that we can&rsquo;t handle the case when
a refresh fails. A way to remedy this is to use the <code>refresh()</code> call&rsquo;s
<em>promise</em> instead of the actual resolved result. This moves the
responsibility of error handling from the service to each dependent
service/controller/component:</p><iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/31/embedded/ allowfullscreen frameborder=0></iframe>
Another issue with the above solution is we are partially back to the
issue we had with watch callback being called multiple times. In this
example it's because the `newList` event is triggered twice on
initialization. This can be overcome by not triggering it on the first
`refresh()` call:
<iframe width=100% height=300 src=http://jsfiddle.net/Ztyx/U9A32/17/embedded/ allowfullscreen frameborder=0></iframe>
I know this became quite a lot of code. It all grew out of being a
simple example, but I think this journey is necessary to fully
understand what considerations goes into making reusable, refreshable,
services in Angular.<p>Last, but not least, don&rsquo;t just rip my example. Many times you are
totally fine with a service that simply fetches resource <em>once</em> per page
load!</p><p>Can I do this much simpler? Tell me in the comments.</p></div><footer></footer></article></section></div><footer class=footer><section class=container>©
2025
Jens Rantil
·
Powered by <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a> & <a href=https://github.com/luizdepra/hugo-coder/ target=_blank rel=noopener>Coder</a>.
[<a href=https://github.com/JensRantil/jensrantil.github.io/tree/cba53b20c33afbbecaa6fd8cc3149dd381e636f7 target=_blank rel=noopener>cba53b2</a>]</section></footer></main><script src=/js/coder.min.6ae284be93d2d19dad1f02b0039508d9aab3180a12a06dcc71b0b0ef7825a317.js integrity="sha256-auKEvpPS0Z2tHwKwA5UI2aqzGAoSoG3McbCw73gloxc="></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-8QE7N3YHJ3"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-8QE7N3YHJ3")</script></body></html>